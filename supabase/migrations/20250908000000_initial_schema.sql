-- 1. Profiles Table
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  avatar_url TEXT
);

-- 2. Products Table
CREATE TABLE IF NOT EXISTS public.products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  name TEXT NOT NULL,
  description TEXT,
  price NUMERIC NOT NULL CHECK (price >= 0),
  image_url TEXT,
  file_url TEXT,
  creator_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE
);

-- 3. Purchases Table
CREATE TABLE IF NOT EXISTS public.purchases (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES public.products(id) ON DELETE RESTRICT,
  UNIQUE(user_id, product_id)
);

-- 4. Set up Row Level Security (RLS)
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.purchases ENABLE ROW LEVEL SECURITY;

-- 5. RLS Policies for Profiles
DROP POLICY IF EXISTS "Users can view their own profile." ON public.profiles;
CREATE POLICY "Users can view their own profile." ON public.profiles FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can insert their own profile." ON public.profiles;
CREATE POLICY "Users can insert their own profile." ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update their own profile." ON public.profiles;
CREATE POLICY "Users can update their own profile." ON public.profiles FOR UPDATE USING (auth.uid() = id) WITH CHECK (auth.uid() = id);

-- 6. RLS Policies for Products
DROP POLICY IF EXISTS "Products are publicly viewable." ON public.products;
CREATE POLICY "Products are publicly viewable." ON public.products FOR SELECT USING (true);

DROP POLICY IF EXISTS "Authenticated users can create products." ON public.products;
CREATE POLICY "Authenticated users can create products." ON public.products FOR INSERT WITH CHECK (auth.role() = 'authenticated');

DROP POLICY IF EXISTS "Creators can update their own products." ON public.products;
CREATE POLICY "Creators can update their own products." ON public.products FOR UPDATE USING (auth.uid() = creator_id) WITH CHECK (auth.uid() = creator_id);

DROP POLICY IF EXISTS "Creators can delete their own products." ON public.products;
CREATE POLICY "Creators can delete their own products." ON public.products FOR DELETE USING (auth.uid() = creator_id);

-- 7. RLS Policies for Purchases
DROP POLICY IF EXISTS "Users can view their own purchases." ON public.purchases;
CREATE POLICY "Users can view their own purchases." ON public.purchases FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can create their own purchases." ON public.purchases;
CREATE POLICY "Users can create their own purchases." ON public.purchases FOR INSERT WITH CHECK (auth.uid() = user_id);

-- 8. Trigger to create a profile for new users
CREATE OR REPLACE FUNCTION public.create_profile_for_new_user()
RETURNS TRIGGER AS $$
DECLARE
  username_from_email TEXT;
BEGIN
  username_from_email := split_part(new.email, '@', 1);
  INSERT INTO public.profiles (id, username, avatar_url)
  VALUES (new.id, username_from_email, new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.create_profile_for_new_user();

COMMENT ON FUNCTION public.create_profile_for_new_user() IS 'Automatically creates a user profile upon new user registration in auth.users.';
-- 1. Create Storage Bucket
INSERT INTO
  storage.buckets (id, name, public)
VALUES
  ('assets', 'assets', true) ON CONFLICT (id) DO NOTHING;

-- 2. Set up RLS policies for the 'assets' bucket

-- Policy: Allow public read access
DROP POLICY IF EXISTS "Public read access for assets" ON storage.objects;
CREATE POLICY "Public read access for assets" ON storage.objects FOR SELECT USING (bucket_id = 'assets');

-- Policy: Allow authenticated users to upload
DROP POLICY IF EXISTS "Authenticated users can upload assets" ON storage.objects;
CREATE POLICY "Authenticated users can upload assets" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'assets');

-- Policy: Allow users to update their own files
DROP POLICY IF EXISTS "Users can update their own assets" ON storage.objects;
CREATE POLICY "Users can update their own assets" ON storage.objects FOR UPDATE TO authenticated USING (auth.uid() = owner) WITH CHECK (bucket_id = 'assets');

-- Policy: Allow users to delete their own files
DROP POLICY IF EXISTS "Users can delete their own assets" ON storage.objects;
CREATE POLICY "Users can delete their own assets" ON storage.objects FOR DELETE TO authenticated USING (auth.uid() = owner);
-- 1. Favorites Table
CREATE TABLE IF NOT EXISTS favorites (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE CASCADE,
  UNIQUE(user_id, product_id) -- Ensures a user can only favorite a product once
);

-- 2. Set up Row Level Security (RLS) for favorites
ALTER TABLE favorites ENABLE ROW LEVEL SECURITY;

-- 3. RLS Policies for Favorites
DROP POLICY IF EXISTS "Users can view their own favorites." ON favorites;
CREATE POLICY "Users can view their own favorites."
ON favorites FOR SELECT
USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert their own favorites." ON favorites;
CREATE POLICY "Users can insert their own favorites."
ON favorites FOR INSERT
WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete their own favorites." ON favorites;
CREATE POLICY "Users can delete their own favorites."
ON favorites FOR DELETE
USING (auth.uid() = user_id);
-- 1. Add new columns to the profiles table for creator-specific information.
ALTER TABLE public.profiles
ADD COLUMN IF NOT EXISTS bio TEXT,
ADD COLUMN IF NOT EXISTS website_url TEXT,
ADD COLUMN IF NOT EXISTS x_url TEXT,
ADD COLUMN IF NOT EXISTS youtube_url TEXT;

-- 2. Add new RLS policy to allow public viewing of profiles.
DROP POLICY IF EXISTS "Anyone can view all profiles." ON profiles;
CREATE POLICY "Anyone can view all profiles."
ON profiles FOR SELECT
USING (true);


-- Add comments for the new columns
COMMENT ON COLUMN profiles.bio IS 'A short biography or description of the creator.';
COMMENT ON COLUMN profiles.website_url IS 'Link to the creator''s personal or professional website.';
COMMENT ON COLUMN profiles.x_url IS 'Link to the creator''s X (formerly Twitter) profile.';
COMMENT ON COLUMN profiles.youtube_url IS 'Link to the creator''s YouTube channel.';
-- Add license_type and terms_of_use to products table
ALTER TABLE public.products
  ADD COLUMN IF NOT EXISTS license_type TEXT,
  ADD COLUMN IF NOT EXISTS terms_of_use TEXT;

-- Add comments for the new columns
COMMENT ON COLUMN public.products.license_type IS 'The type of license for the product (e.g., "Standard License", "Extended License").';
COMMENT ON COLUMN public.products.terms_of_use IS 'The detailed terms of use for the product.';
-- 1. Categories Table
CREATE TABLE IF NOT EXISTS public.categories (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.categories IS 'Stores product categories.';

-- 2. Tags Table
CREATE TABLE IF NOT EXISTS public.tags (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT UNIQUE NOT NULL,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
COMMENT ON TABLE public.tags IS 'Stores product tags.';

-- 3. Product_Tags Junction Table
CREATE TABLE IF NOT EXISTS public.product_tags (
    product_id BIGINT NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
    tag_id BIGINT NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
    PRIMARY KEY (product_id, tag_id)
);
COMMENT ON TABLE public.product_tags IS 'Associates products with tags.';

-- 4. Add category_id to products table
ALTER TABLE public.products
ADD COLUMN IF NOT EXISTS category_id BIGINT REFERENCES public.categories(id);
-- Add new RLS policies for categories
DROP POLICY IF EXISTS "Admin full access on categories" ON public.categories;
CREATE POLICY "Admin full access on categories"
ON public.categories
FOR ALL
USING (public.is_claims_admin())
WITH CHECK (public.is_claims_admin());

DROP POLICY IF EXISTS "Public can read categories" ON public.categories;
CREATE POLICY "Public can read categories"
ON public.categories
FOR SELECT
USING (true);

-- Add new RLS policies for tags
DROP POLICY IF EXISTS "Admin full access on tags" ON public.tags;
CREATE POLICY "Admin full access on tags"
ON public.tags
FOR ALL
USING (public.is_claims_admin())
WITH CHECK (public.is_claims_admin());

DROP POLICY IF EXISTS "Public can read tags" ON public.tags;
CREATE POLICY "Public can read tags"
ON public.tags
FOR SELECT
USING (true);
-- This migration was created manually because the `supabase` CLI was not available in the environment.
-- It defines the RLS helper functions as requested.

/**
* RLS HELPER FUNCTIONS
* - These functions are used by RLS policies to check user claims.
*/

-- JWTから指定されたカスタムクレームを読み取る
create or replace function get_my_claim(claim TEXT) returns jsonb as $$
  select nullif(current_setting('request.jwt.claims', true), '')::jsonb -> claim
$$ language sql stable;

-- 現在のユーザーが管理者クレームを持っているか確認する
create or replace function is_claims_admin() returns boolean as $$
  select coalesce(get_my_claim('claims_admin')::boolean, false)
$$ language sql stable;
-- Drop the existing, more restrictive policies for the 'tags' table.
DROP POLICY IF EXISTS "Admin full access on tags" ON public.tags;
DROP POLICY IF EXISTS "Public can read tags" ON public.tags;
DROP POLICY IF EXISTS "Authenticated users can insert tags" ON public.tags;
DROP POLICY IF EXISTS "Admins can update tags" ON public.tags;
DROP POLICY IF EXISTS "Admins can delete tags" ON public.tags;

-- 1. Public Read Access: All users can view tags.
CREATE POLICY "Public can read tags"
ON public.tags
FOR SELECT
USING (true);

-- 2. Authenticated Insert Access: Any logged-in user can create a new tag.
CREATE POLICY "Authenticated users can insert tags"
ON public.tags
FOR INSERT
WITH CHECK (auth.role() = 'authenticated');

-- 3. Admin Update Access: Only admins can rename existing tags.
CREATE POLICY "Admins can update tags"
ON public.tags
FOR UPDATE
USING (public.is_claims_admin())
WITH CHECK (public.is_claims_admin());

-- 4. Admin Delete Access: Only admins can delete existing tags.
CREATE POLICY "Admins can delete tags"
ON public.tags
FOR DELETE
USING (public.is_claims_admin());
CREATE OR REPLACE FUNCTION public.get_sales_history()
RETURNS TABLE (
  product_id BIGINT,
  product_name TEXT,
  price NUMERIC,
  purchased_at TIMESTAMPTZ,
  purchaser_username TEXT
)
LANGUAGE plpgsql STABLE SECURITY INVOKER AS $$
BEGIN
  RETURN QUERY
  SELECT
    p.id,
    p.name,
    p.price,
    pu.created_at,
    purchaser_profile.username
  FROM
    public.purchases pu
  JOIN
    public.products p ON pu.product_id = p.id
  JOIN
    public.profiles purchaser_profile ON pu.user_id = purchaser_profile.id
  WHERE
    p.creator_id = auth.uid()
  ORDER BY
    pu.created_at DESC;
END;
$$;
-- Create contacts table
CREATE TABLE IF NOT EXISTS public.contacts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  name TEXT,
  email TEXT,
  subject TEXT,
  message TEXT,
  is_read BOOLEAN DEFAULT false
);

-- Add comments for the new columns
COMMENT ON TABLE public.contacts IS 'Stores contact form submissions.';
COMMENT ON COLUMN public.contacts.is_read IS 'Indicates if the contact message has been read by an admin.';

-- RLS Policies for contacts table
ALTER TABLE public.contacts ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "Allow admin full access to contacts" ON public.contacts;
CREATE POLICY "Allow admin full access to contacts"
ON public.contacts
FOR ALL
USING (public.is_claims_admin())
WITH CHECK (public.is_claims_admin());
-- 1. 全ユーザーの情報を安全に取得するための関数
--    `security definer`により、この関数は高い権限で実行されます。
create or replace function get_all_users()
returns table (
  id uuid,
  email text,
  created_at timestamptz,
  last_sign_in_at timestamptz,
  is_admin boolean
) as $$
begin
  -- 関数を呼び出せるのを管理者のみに制限します
  if not is_claims_admin() then
    raise exception 'Admin privileges required';
  end if;

  return query
  select
    u.id,
    u.email,
    u.created_at,
    u.last_sign_in_at,
    coalesce((u.raw_app_meta_data->>'claims_admin')::boolean, false) as is_admin
  from auth.users u
  order by u.created_at desc;
end;
$$ language plpgsql security definer;


-- 2. ユーザーの管理者権限を更新するための関数
create or replace function set_admin_status(user_id uuid, p_is_admin boolean)
returns void as $$
begin
  -- 関数を呼び出せるのを管理者のみに制限します
  if not is_claims_admin() then
    raise exception 'Admin privileges required';
  end if;

  update auth.users
  set raw_app_meta_data = raw_app_meta_data || jsonb_build_object('claims_admin', p_is_admin)
  where id = user_id;
end;
$$ language plpgsql security definer;
