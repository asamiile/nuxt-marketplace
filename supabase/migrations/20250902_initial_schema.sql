-- 1. Profiles Table
-- This table stores user profile information.
-- It is linked to the auth.users table via a one-to-one relationship.
CREATE TABLE profiles (
  id UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT UNIQUE,
  avatar_url TEXT
);

-- Comments for profiles table
COMMENT ON TABLE profiles IS 'Stores public profile information for each user.';
COMMENT ON COLUMN profiles.id IS 'Reference to the user in auth.users.';
COMMENT ON COLUMN profiles.username IS 'Public username, must be unique.';
COMMENT ON COLUMN profiles.avatar_url IS 'URL for the user''s avatar image.';


-- 2. Products Table
-- This table stores information about the digital assets for sale.
CREATE TABLE products (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  name TEXT NOT NULL,
  description TEXT,
  price NUMERIC NOT NULL CHECK (price >= 0),
  image_url TEXT,
  file_url TEXT,
  creator_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE
);

-- Comments for products table
COMMENT ON TABLE products IS 'Stores information about digital assets available for purchase.';
COMMENT ON COLUMN products.creator_id IS 'The user who created the product.';


-- 3. Purchases Table
-- This table links users to the products they have purchased.
CREATE TABLE purchases (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  user_id UUID NOT NULL REFERENCES profiles(id) ON DELETE CASCADE,
  product_id BIGINT NOT NULL REFERENCES products(id) ON DELETE RESTRICT,
  UNIQUE(user_id, product_id) -- Ensures a user can only buy a product once
);

-- Comments for purchases table
COMMENT ON TABLE purchases IS 'Records which user has purchased which product.';


-- 4. Set up Row Level Security (RLS)
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE purchases ENABLE ROW LEVEL SECURITY;


-- 5. RLS Policies for Profiles
CREATE POLICY "Users can view their own profile."
ON profiles FOR SELECT
USING (auth.uid() = id);

CREATE POLICY "Users can insert their own profile."
ON profiles FOR INSERT
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update their own profile."
ON profiles FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- Note: Deletion of profiles is handled by the ON DELETE CASCADE on the `id` column,
-- which will delete the profile when the corresponding auth.users record is deleted.


-- 6. RLS Policies for Products
CREATE POLICY "Products are publicly viewable."
ON products FOR SELECT
USING (true);

CREATE POLICY "Authenticated users can create products."
ON products FOR INSERT
WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Creators can update their own products."
ON products FOR UPDATE
USING (auth.uid() = creator_id)
WITH CHECK (auth.uid() = creator_id);

CREATE POLICY "Creators can delete their own products."
ON products FOR DELETE
USING (auth.uid() = creator_id);


-- 7. RLS Policies for Purchases
CREATE POLICY "Users can view their own purchases."
ON purchases FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can create their own purchases."
ON purchases FOR INSERT
WITH CHECK (auth.uid() = user_id);

-- Note: By default, users cannot update or delete their purchase history. This is generally desired behavior.


-- 8. Trigger to create a profile for new users
-- This function is triggered when a new user signs up in Supabase Auth.
-- It automatically creates a corresponding record in the public.profiles table.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, username)
  VALUES (new.id, new.raw_user_meta_data->>'username'); -- Assumes username is passed in metadata on signup
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- The trigger that calls the function
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- To make it easier for users, let's also create a trigger to copy the initial username from the email
CREATE OR REPLACE FUNCTION public.handle_new_user_fallback()
RETURNS TRIGGER AS $$
BEGIN
  -- Check if a profile already exists. If so, do nothing.
  IF EXISTS (SELECT 1 FROM public.profiles WHERE id = new.id) THEN
    RETURN new;
  END IF;

  -- Insert a new profile, using the email as a fallback for the username.
  INSERT INTO public.profiles (id, username)
  VALUES (new.id, new.email);
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created_fallback
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user_fallback();

-- Let's adjust the first trigger to be more robust and use the second one as a fallback
-- It's better to have one trigger that handles all logic.

-- Drop the previous triggers and function to redefine them cleanly.
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
DROP TRIGGER IF EXISTS on_auth_user_created_fallback ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.handle_new_user_fallback();

-- A single, robust function to create a profile for a new user.
CREATE OR REPLACE FUNCTION public.create_profile_for_new_user()
RETURNS TRIGGER AS $$
DECLARE
  -- You can add logic here to extract a username from metadata if you pass it during sign-up
  -- For example: new.raw_user_meta_data->>'user_name'
  -- For now, we will use the email as a default username, or a part of it.
  username_from_email TEXT;
BEGIN
  -- Extract the part of the email before the '@' symbol.
  username_from_email := split_part(new.email, '@', 1);

  INSERT INTO public.profiles (id, username, avatar_url)
  VALUES (new.id, username_from_email, new.raw_user_meta_data->>'avatar_url');
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- The trigger that calls the new function
CREATE TRIGGER on_auth_user_created
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.create_profile_for_new_user();

-- Add a comment to the function to explain its purpose
COMMENT ON FUNCTION public.create_profile_for_new_user() IS 'Automatically creates a user profile upon new user registration in auth.users.';
